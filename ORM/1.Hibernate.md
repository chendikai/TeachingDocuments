<h1 align="center">Hibernate框架</h1>

Git学习：https://www.cnblogs.com/anding/p/16987769.html

#### 一、Hibernate框架

​	Hibernate是持久层的一个框架，也是一个ORM（Object Relational Mapping）框架，在对象和关系型数据库（ Oracle、MySQL、SQL Server、Microsoft Access、DB2 等）之间建立某种映射关系，以实现直接存取对象来操作数据库。

​	ORM（对象关系映射）思想，所谓的ORM就是利用描述对象和数据库表之间的映射元数据，自动把Java应用程序的对象，持久化到关系型数据库的表中。通过操作Java对象，就可以完成对数据库的操作，可以把ORM理解为关系型数据库和对象的一个纽带，开发人员只需要关注纽带一端映射的对象即可。

#### 二、Hibernate优势

1. Hibernate对JDBC访问数据库的代码做了一个轻量级的封装，大大简化了数据访问层的繁琐操作，减少代码的复杂度，和减少内存消耗，加快了运行速度
2. Hibernate是一个基于JDBC的主流框架，是一个优秀ORM实现，很大程度上简化了DAO层操作
3. Hibernate性能较好，灵活性较高，它可以支持一对一、一对多、多对多
4. 可扩展性强，当本身功能不够时，可以自行编码进行扩展

#### 三、Hibernate入门案例

##### 1、下载Hibernate[框架](https://hibernate.org/orm/releases/)

![image-20220228083333227](/TyporaPic/image-20220228083333227.png)

##### 2、Hibernate解压后的目录

![image-20220228083433178](/TyporaPic/image-20220228083433178.png)

#### 四、创建Hibernate项目

##### 1、创建工程

- 修改项目文件编码格式

    ![image-20220228084348234](/TyporaPic/image-20220228084348234.png)

- 创建普通的Java工程

    ![image-20220228084450891](/TyporaPic/image-20220228084450891.png)

##### 2、导入jar包

​	在项目目录下新建lib目录，将下面的jar包导入lib目录

- 导入hibernate核心jar包

![image-20220228083606836](/TyporaPic/image-20220228083606836.png)

- 导入数据库驱动jar包

    ![image-20220228085944502](/TyporaPic/image-20220228085944502.png)

- 导入日志包

    ![image-20220228090058129](/TyporaPic/image-20220228090058129.png)

- 将所有jar包添加到项目工程中

    ![image-20220228090224360](/TyporaPic/image-20220228090224360.png)

##### 3、创建实体类

```java
package com.hbnu.pojo;

/**
 * @author chendikai
 */
public class User {
    // hibernate要求实体类必须要有一个唯一属性值
    private int uid;
    private String username;
    private String address;

    public int getUid() {
        return uid;
    }

    public void setUid(int uid) {
        this.uid = uid;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }
}
```

#### 五、Hibernate配置文件

##### 1、映射关系配置文件

- 映射关系配置文件路径没有限制，官方建议将映射配置文件和实体类放在同一路径下

- 映射关系配置文件名称没有限制，但后缀为xml，官方建议映射关系配置文件命名为：实体类名.hbm.xml

    ```xml
    <?xml version="1.0" encoding="utf-8" ?>
    <!-- 引入映射关系配置文件约束 -->
    <!DOCTYPE hibernate-mapping PUBLIC
            "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
            "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
    <hibernate-mapping>
        <!-- 配置对象和数据库表之间的映射关系
        nam..实体类的全路径名
        tabl..数据库表的名称
        -->
        <class name="com.hbnu.pojo.User" table="tb_user">
            <!-- 配置主键映射关系
             nam..实体类中的属性名
             column:数据库表中主键名称，column属性可以省略，如果省略，则自动生成的数据库表主键名称和实体类名称一致
             -->
            <id name="uid" column="id">
                <!-- 主键生成策略 -->
                <generator class="native"></generator>
            </id>
            
            <!-- 配置其他属性的映射关系 -->
            <property name="username" column="name"/>
            <property name="address" column="addr"></property>
        </class>
    </hibernate-mapping>
    ```

##### 2、核心配置文件

- 核心配置文件路径必须在src目录下

- 核心配置文件名称必须为hibernate.cfg.xml

- hibernate在工作时，会直接加载核心配置文件，不会直接加载映射关系配置文件

    ```xml
    <?xml version="1.0" encoding="utf-8" ?>
    <!-- 引入核心配置文件约束 -->
    <!DOCTYPE hibernate-configuration PUBLIC
            "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
            "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd">
    <hibernate-configuration>
        <!-- 配置hibernate核心配置文件 -->
        <session-factory>
            <!-- 1、数据库信息 必需 -->
            <property name="hibernate.connection.driver_class">com.mysql.cj.jdbc.Driver</property>
            <property name="hibernate.connection.url">jdbc:mysql://localhost:3306/classDB?serverTimezone=GMT&amp;useSSL=false&amp;characterEncoding=utf-8</property>
            <property name="hibernate.connection.username">root</property>
            <property name="hibernate.connection.password">chendikai</property>
    
            <!-- 2、hibernate信息 非必需 -->
            <!-- 在控制台输出hibernate底层生成的SQL语句 -->
            <property name="show_sql">true</property>
            <!-- 格式化hibernate底层生成的SQL语句 -->
            <property name="format_sql">true</property>
            <!-- 数据库方言 -->
            <property name="hibernate.dialect">org.hibernate.dialect.MySQL5Dialect</property>
            <!-- hibernate自动创建数据库表，如果表已经存在，则更新表，如果不存在，则创建表格 -->
            <property name="hibernate.hbm2ddl.auto">update</property>
    
            <!-- 3、引用hibernate映射关系配置文件，mapping标签必须在property标签后面 必需 -->
            <mapping resource="com/hbnu/config/user.hbm.xml"></mapping>
        </session-factory>
    </hibernate-configuration>
    ```

##### 3、Hibernate运行测试

```java
package com.hbnu.test;

import com.hbnu.pojo.User;
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.cfg.Configuration;
import org.junit.Test;

/**
 * @author chendikai
 */
public class HibernateTest {

    /**
     * 添加数据到数据库表中
     */
    @Test
    public void insertData() {
        // 1、加载hibernate配置文件（解析核心配置文件）
        Configuration configure = new Configuration().configure();

        // 2、根据配置对象configure构建会话工厂
        SessionFactory sessionFactory = configure.buildSessionFactory();

        // 3、根据会话工厂创建会话对象
        Session session = sessionFactory.openSession();

        // 4、通过调用会话对象的相关方法执行数据库的CRUD操作
        User user = new User();
        user.setUsername("chendikai");
        user.setAddress("HuangShi");
        session.save(user);  // 操作Java中的对象，保存对象中的数据到数据库表中

        // 5、关闭会话和会话工厂
        session.close();
        sessionFactory.close();
    }
}
```

##### 4、Hibernate执行过程

1. 通过Configuration对象加载hibernate核心配置文件，间接加载映射关系配置文件
2. 通过Configuration对象构建会话工厂SessionFactory
3. 通过会话工厂SessionFactory对象创建会话对象Session
4. 通过调用会话对象Session的相关方法执行数据库的CRUD操作
5. 关闭会话对象和会话工厂

**课后作业：**

1. 谈谈你对Git的理解，使用Git进行代码提交和代码拉取的过程，如何解决代码提交中的冲突？
2. Hibernate框架中映射关系配置文件的作用是什么、限制条件有哪些、配置的内容有哪些？
3. Hibernate框架中核心配置文件的作用是什么、限制条件有哪些、配置的内容有哪些？
4. Hibernate框架的核心配置文件中为什么要配置mapping标签引入映射配置文件？
5. 谈谈Hibernate的执行过程。

#### 六、相关API

- Configuration

    直接加载核心配置文件，间接加载映射关系配置文件，并将配置文件信息封装到Configuration对象中

- SessionFactory

    SessionFactory对象的创建是通过Configruation对象，根据配置文件的配置信息创建会话工厂，同时在创建会话工厂的过程中自动创建数据库表，这个过程是比较耗资源的。在Hibernate项目中，建议一个项目只创建一次SessionFactory对象，可以通过工具类来实现

    ```java
    package com.hbnu.util;
    
    import org.hibernate.SessionFactory;
    import org.hibernate.cfg.Configuration;
    
    /**
     * @author chendikai
     */
    public class HibernateUtils {
        
        private static Configuration configuration;
        private static SessionFactory sessionFactory;
        
        static {
            configuration = new Configuration().configure();
            sessionFactory = configuration.buildSessionFactory();
        }
        
        public static SessionFactory getSessionFactory() {
            return sessionFactory;
        }
        
    }
    ```
    
- Session

    1. Session对象类似于JDBC中的Connection

    2. Session对象有操作数据库的相关方法

        添加	save()

        修改	update()

        删除	delete()

        根据主键id查询	get(id)

    3. Session是单线程的

#### 七、主键生成策略

- increment

    适用于long、short或int类型主键，由Hibernate提供自动递增的方式生成唯一标识符，每次增量为1。只有当没有其他线程向同一张表中插入数据时才可以使用，不能再多线程环境下使用

- identity

    适用于long、short或int类型主键，采用底层数据库本身提供的主键生成标识符。在DB2、MySQL、MS SQL Server、Sybase和HypersonicSQL数据库中可以使用该生成器，该生成器要求在数据库中把主键定义成为自增类型。Oracle没有自动增长

- sequence 

    适用于long、short或int类型主键，Hibernate根据底层数据库序列生成标识符。条件是数据库支持序列。如oralce、DB、SAP DB、PostgerSQL、McKoi中的sequence，MySQL这种不支持sequence

- native(掌握)

    根据底层数据库对自动生成标识符的能力来选择identity、sequence、hilo三种生成器中的一种，适合跨数据库平台开发

- uuid(掌握)

    Hibernate采用128位的UUID算法来生成标识符。该算法能够在网络环境中生成唯一的字符串标识符，其UUID被编码为一个长度为32位的十六进制字符串。按照开放软件基金会(OSF)制定的标准计算，用到了以太网卡地址、纳秒级时间、芯片ID码和许多可能的数字，uuid长度大，占用空间大，跨数据库，不用访问数据库就生成主键值，所以效率高且能保证唯一性，移植非常方便，推荐使用。

- assigned

    由Java程序负责生成标识符，Hibernate不管理主键，用户手动设置主键的值。如果不指定id元素的generator属性，则默认使用该主键生成策略

#### 八、对象的CRUD

##### 1、查询数据

```java
/**
 * 查询数据库表中的信息
 */
@Test
public void queryData() {
    SessionFactory sessionFactory = HibernateUtils.getSessionFactory();

    Session session = sessionFactory.openSession();

    // 调用session中的方法查询数据库表
    User user = session.get(User.class, 1);

    System.out.println(user);

    session.close();
    sessionFactory.close();
}
```

##### 2、修改数据

​	先查询要修改的数据，再修改数据，只要我们改变数据库中的数据，则必须添加事务

```java
/**
 * 修改数据库数据
 */
@Test
public void updateData() {
    SessionFactory sessionFactory = HibernateUtils.getSessionFactory();

    Session session = sessionFactory.openSession();

    Transaction transaction = session.beginTransaction();  // 开启事务

    // 先查询要修改的数据，再修改数据，只要我们改变数据库中的数据，则必需添加事务
    User user = session.get(User.class, 1);
    user.setAddress("WuHan");
    session.update(user);

    transaction.commit();  // 提交事务

    session.close();
    sessionFactory.close();
}
```

##### 3、删除数据

​	先查询要删除的数据，再删除数据，只要我们改变数据库中的数据，则必须添加事务

```java
/**
 * 删除数据库表中的数据
 */
@Test
public void testDelete() {
    SessionFactory sessionFactory = HibernateUtils.getSessionFactory();

    Session session = sessionFactory.openSession();

    Transaction transaction = session.beginTransaction();  // 开启事务

    // 先查询，再删除
    User user = session.get(User.class, 1);
    session.delete(user);

    transaction.commit();  // 提交事务

    session.close();
    sessionFactory.close();
}
```

#### 九、Hibernate中对象的状态

​	在Hibernate中，实体类对象有3种状态，瞬时态、托管态、持久态。

- 瞬时态：瞬时态对象没有id值（主键值），与session对象没有关联

- 托管态：托管态对象有id值（主键值），与session对象没有关联

- 持久态：持久态对象有id值（主键值），与session对象有关联

    使用savaOrUpdate()测试不同状态的对象所执行的操作

##### 1、瞬时态

```java
@Test
public void testSaveOrUpdate() {
    SessionFactory sessionFactory = HibernateUtils.getSessionFactory();

    Session session = sessionFactory.openSession();

    // 瞬时态对象：既没有主键值（id值），也与session对象没有关联
    User user = new User();
    user.setUsername("陈迪凯");
    user.setAddress("黄石");
    session.saveOrUpdate(user);  // 对于瞬时态对象，savaOrUpdate方法执行的是添加操作

    session.close();
    sessionFactory.close();
}
```

测试结果

![image-20220307082207627](/TyporaPic/image-20220307082207627.png)

##### 2、托管态

```java
@Test
public void testSaveOrUpdate() {
    SessionFactory sessionFactory = HibernateUtils.getSessionFactory();

    Session session = sessionFactory.openSession();

    // 瞬时态对象：既没有主键值（id值），也与session对象没有关联
    // User user = new User();
    // user.setUsername("陈迪凯");
    // user.setAddress("黄石");
    // session.saveOrUpdate(user);  // 对于瞬时态对象，saveOrUpdate方法执行的是添加操作

    Transaction transaction = session.beginTransaction();

    // 托管态对象：对象有主键值（id值），但与session对象没有关联
    User user = new User();
    user.setUid(2);
    user.setUsername("张无忌");
    user.setAddress("光明顶");
    // 对于托管态对象，saveOrUpdate方法执行的是修改操作，但是必须添加事务，同时要保证主键值（id值）在数据库表中已存在
    session.saveOrUpdate(user);  

    transaction.commit();

    session.close();
    sessionFactory.close();
}
```

测试结果

![image-20220307083111563](/TyporaPic/image-20220307083111563.png)

##### 3、持久态

```java
@Test
public void testSaveOrUpdate() {
    SessionFactory sessionFactory = HibernateUtils.getSessionFactory();

    Session session = sessionFactory.openSession();

    // 瞬时态对象：既没有主键值（id值），也与session对象没有关联
    // User user = new User();
    // user.setUsername("陈迪凯");
    // user.setAddress("黄石");
    // session.saveOrUpdate(user);  // 对于瞬时态对象，saveOrUpdate方法执行的是添加操作

    Transaction transaction = session.beginTransaction();

    // 托管态对象：对象有主键值（id值），但与session对象没有关联
    // User user = new User();
    // user.setUid(2);
    // user.setUsername("张无忌");
    // user.setAddress("武当山");
    // 对于托管态对象，saveOrUpdate方法执行的是修改操作，但是必须添加事务，同时要保证主键值（id值）在数据库表中已存在
    // session.saveOrUpdate(user);

    // 持久态对象：对象有主键值（id值），同时与session对象有关联
    User user = session.get(User.class, 2);
    user.setUsername("张翠山");
    session.saveOrUpdate(user); // 对于持久态对象，saveOrUpdate方法执行的是修改操作，同时必须添加事务

    transaction.commit();

    session.close();
    sessionFactory.close();
}
```

测试结果

![image-20220307083746483](/TyporaPic/image-20220307083746483.png)

#### 十、Hibernate中的缓存

​		Hibernate框架提供了很多的优化策略，缓存就属于其中的一种优化策略，Hibernate中支持一级缓存和二级缓存

- 在Hibernate中，一级缓存默认是开启的，一级缓存的作用范围为会话级别（session范围级别），缓存中存储的数据为持久态对象数据
- 在Hibernate中，支持二级缓存策略，可以通过配置文件手动开启二级缓存，但是目前Hibernate二级缓存不再使用，而是被redis替代，二级缓存的作用范围为会话工厂级别（SessionFactory范围级别）

##### 1、验证一级缓存是否开启

```java
/**
 * 验证一级缓存是否开启
 */
@Test
public void testCache() {
    SessionFactory sessionFactory = HibernateUtils.getSessionFactory();

    Session session = sessionFactory.openSession();

    User user1 = session.get(User.class, 2);
    System.out.println(user1);

    User user2 = session.get(User.class, 2);
    System.out.println(user2);

    session.close();
    sessionFactory.close();
}
```

测试结果

![image-20220307085537311](/TyporaPic/image-20220307085537311.png)

缓存原理：当我们第一次查询数据的时候，先去缓存中查找，如果缓存中没有，则再去数据库中查找，从数据库中查询到结果后，将结果返回给缓存，再将缓存中的查询结果返回给用户，如果缓存中有要查找的数据，则不需要再去查询数据库，直接从缓存中返回要查找的数据。当我们下一次查询同样的数据时，直接从缓存中拿。

![image-20220307090716894](/TyporaPic/image-20220307090716894.png)

##### 2、缓存的功能

​		hibernate缓存有一个功能，就是修改完持久态数据后，不需要调用session对象的update方法或saveOrUpdate方法修改数据库表，而是自动保存修改后的持久态数据

```java
/**
 * hibernate缓存功能：自动保存修改后的持久态对象数据
 */
@Test
public void testCacheCharacter() {
    SessionFactory sessionFactory = HibernateUtils.getSessionFactory();

    Session session = sessionFactory.openSession();

    Transaction transaction = session.beginTransaction();

    User user = session.get(User.class, 2);
    user.setUsername("张君宝");

    transaction.commit();

    session.close();
    sessionFactory.close();

}
```

测试结果

![image-20220307091346089](/TyporaPic/image-20220307091346089.png)

![image-20220307092559231](/TyporaPic/image-20220307092559231.png)

**课后作业**

1. 使用Session对象进行数据库表的修改或删除操作有什么注意的地方。
2. 在Hibernate中对象有哪些状态，分别有什么特点。
3. 谈谈你对缓存的理解。
4. 对于持久态的对象，hibernate中的缓存有什么功能，并说明该功能的原理。

#### 十一、Hibernate事务

##### 1、事务相关概念

###### 1.1、什么是事务

​	数据库事务是指作为单个逻辑工作单元执行的一系列操作（SQL语句）。这些操作要么全部执行，要么全部不执行

###### 1.2、事务的特性(ACID)

- 原子性 （atomicity）：强调事务的不可分割

    原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响

- 一致性 （consistency）：事务的执行的前后数据的完整性保持一致

    一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态

    拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性

- 隔离性 （isolation）：一个事务执行的过程中,不应该受到其他事务的干扰

    隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离

    即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行

- 持久性（durability） ：事务一旦结束,数据就持久到数据库

    持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作

    例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务已经正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误

###### 1.3、不考虑隔离性产生的问题

- 脏读

    脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。

    当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。

- 不可重复读

    不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。

- 幻读（虚读）

    幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。

###### 1.4、设置事务隔离级别

​	SQL标准中定义了四种隔离级别，并规定了每种隔离级别下上述几个问题是否存在。一般来说，隔离级别越低，系统开销越低，可支持的并发越高，但隔离性也越差。隔离级别与读问题的关系如下:

![](/TyporaPic/transaction-1618321494213.png)

​	Hibernate框架中设置事务的隔离级别

```xml
<!-- 设置事务的隔离级别 -->
<property name="hibernate.connection.isolation">4</property>
```

- 值为1：事务隔离级别为“读未提交”
- 值为2：事务隔离级别为“读已提交”
- 值为3：事务隔离级别为“可重复读”
- 值为4：事务隔离级别为“可串行化”

##### 2、事务的规范性代码

###### 2.1、规范性代码结构

```java
// 事务规范性代码结构
try {
	// 开启事务
	
	// 事务操作性代码
	
	// 提交事务
} catch(Exception e) {
	e.printStackTrace();
	// 回滚事务
	
} finally {
	// 关闭资源
}
```

###### 2.2、事务规范性示例

```java
/**
 * 事务规范性代码示例
 */
@Test
public void testTransaction() {
    SessionFactory sessionFactory = null;
    Session session = null;
    Transaction transaction = null;
    
    try {
        sessionFactory = HibernateUtils.getSessionFactory();
        session = sessionFactory.openSession();
        
        // 开启事务
        transaction = session.beginTransaction();

        // 事务操作
        User user = session.get(User.class, 2);
        user.setUsername("小昭");
        
        // 提交事务
        transaction.commit();
    } catch (HibernateException e) {
        e.printStackTrace();
        // 回滚事务
        transaction.rollback();
        
    } finally {
        session.close();
        sessionFactory.close();
    }
}
```

##### 3、Hibernate绑定session

​	现实中一个项目的开发是由团队开发，当多人开发同一个Hibernate项目时，很难保证session是单线程，所以要实现真正的session单线程，需要将session绑定到本地线程，这个时候可以不用关闭session对象。

###### 3.1、session绑定本地线程

​	修改Hibernate核心配置文件

```xml
<!-- session绑定本地线程 -->
<property name="current_session_context_class">thread</property>
```

###### 3.2、获取绑定后的session

​	修改Hibernate工具类

```java
public static Session getSession() {
    return sessionFactory.getCurrentSession();  // 返回与本地线程绑定的session对象
}
```

#### 十二、其他API

##### 1、Query

​	通常查询数据库用SQL语言，而在Hibernate框架中，可以使用HQL（Hibernate Query Language）语言查询数据库，其实HQL语言和SQL语言很相似，SQL语言操作的是数据库表和数据库表中的字段，而HQL语言操作的是Hibernate框架中的实体类对象和实体类对象中的属性。

```java
SQL：select name, addr from tb_user where name = 'chendikai'

HQL：select username, address from User where username = 'chendikai'
```

###### 1.1、查询所有数据

```java
@Test
public void testQuery() {
    SessionFactory sessionFactory = HibernateUtils.getSessionFactory();

    Session session = sessionFactory.openSession();
    
    // Session session = HibernateUtils.getSession();  // 获取与本地线程绑定的session对象，需要事务支持
    // Transaction transaction = session.beginTransaction();

    // 查询所有数据
    String hql = "from User";
    Query<User> query = session.createQuery(hql, User.class);

    List<User> userList = query.list();
    
    // transaction.commit();

    for (User user : userList) {
        System.out.println(user);
    }
}
```

###### 1.2、查询单一属性

```java
@Test
public void testQuery() {
    SessionFactory sessionFactory = HibernateUtils.getSessionFactory();

    Session session = sessionFactory.openSession();

    // 查询所有数据
    // String hql = "from User";
    // Query<User> query = session.createQuery(hql, User.class);
    //
    // List<User> userList = query.list();
    //
    // for (User user : userList) {
    //     System.out.println(user);
    // }

    // 查询单一属性
    String hql = "select username from User";
    Query<String> query = session.createQuery(hql, String.class);

    List<String> list = query.list();
    for (String name : list) {
        System.out.println(name);
    }
}
```

###### 1.3、查询多个属性

```java
@Test
public void testQuery() {
    SessionFactory sessionFactory = HibernateUtils.getSessionFactory();

    Session session = sessionFactory.openSession();

    // 查询所有数据
    // String hql = "from User";
    // Query<User> query = session.createQuery(hql, User.class);
    //
    // List<User> userList = query.list();
    //
    // for (User user : userList) {
    //     System.out.println(user);
    // }

    // 查询单一属性
    // String hql = "select username from User";
    // Query<String> query = session.createQuery(hql, String.class);
    //
    // List<String> list = query.list();
    // for (String name : list) {
    //     System.out.println(name);
    // }

    // 查询多个属性
    String hql = "select username, address from User";
    Query<Object[]> query = session.createQuery(hql, Object[].class);
    List<Object[]> list = query.list();
    for (Object[] objects : list) {
        System.out.println(objects[0] + ">" + objects[1]);
    }
}
```

###### 1.4、条件查询

```java
@Test
public void testQuery() {
    SessionFactory sessionFactory = HibernateUtils.getSessionFactory();

    Session session = sessionFactory.openSession();

    // 查询所有数据
    // String hql = "from User";
    // Query<User> query = session.createQuery(hql, User.class);
    //
    // List<User> userList = query.list();
    //
    // for (User user : userList) {
    //     System.out.println(user);
    // }

    // 查询单一属性
    // String hql = "select username from User";
    // Query<String> query = session.createQuery(hql, String.class);
    //
    // List<String> list = query.list();
    // for (String name : list) {
    //     System.out.println(name);
    // }

    // 查询多个属性
    // String hql = "select username, address from User";
    // Query<Object[]> query = session.createQuery(hql, Object[].class);
    // List<Object[]> list = query.list();
    // for (Object[] objects : list) {
    //     System.out.println(objects[0] + ">" + objects[1]);
    // }

    // 条件查询
    // String hql = "from User where username = ?0 and address = ?1";
    // Query<User> query = session.createQuery(hql, User.class);
    // query.setParameter(0, "小昭");
    // query.setParameter(1, "武当山");
    // List<User> list = query.list();
    // for (User user : list) {
    //     System.out.println(user);
    // }

    String hql = "from User where username = :username or address = :address";
    Query<User> query = session.createQuery(hql, User.class);
    query.setParameter("username", "小昭");
    query.setParameter("address", "武当山");
    List<User> list = query.list();
    for (User user : list) {
        System.out.println(user);
    }
}
```

##### 2、Criteria

###### 2.1、查询所有数据

```java
/**
 * API：Criteria
 */
@Test
public void testCriteria() {
    SessionFactory sessionFactory = HibernateUtils.getSessionFactory();

    Session session = sessionFactory.openSession();

    CriteriaBuilder criteriaBuilder = session.getCriteriaBuilder();

    // 查询所有
    CriteriaQuery<User> criteriaQuery = criteriaBuilder.createQuery(User.class);
    // 根条件
    Root<User> root = criteriaQuery.from(User.class);
    Query<User> query = session.createQuery(criteriaQuery);
    List<User> userList = query.list();
    for (User user : userList) {
        System.out.println(user);
    }
}
```

###### 2.2、查询单一属性

```java
/**
 * API：Criteria
 */
@Test
public void testCriteria() {
    SessionFactory sessionFactory = HibernateUtils.getSessionFactory();

    Session session = sessionFactory.openSession();

    CriteriaBuilder criteriaBuilder = session.getCriteriaBuilder();

    // 查询所有
    // CriteriaQuery<User> criteriaQuery = criteriaBuilder.createQuery(User.class);
    // // 跟条件
    // Root<User> root = criteriaQuery.from(User.class);
    // Query<User> query = session.createQuery(criteriaQuery);
    // List<User> userList = query.list();
    // for (User user : userList) {
    //     System.out.println(user);
    // }

    // 查询单一属性
    CriteriaQuery<String> criteriaQuery = criteriaBuilder.createQuery(String.class);
    Root<User> root = criteriaQuery.from(User.class);
    // 查询的字段
    criteriaQuery.select(root.get("username"));
    Query<String> query = session.createQuery(criteriaQuery);
    List<String> list = query.list();
    for (String s : list) {
        System.out.println("用户名：" + s);
    }
}
```

###### 2.3、条件查询

```java
/**
 * API：Criteria
 */
@Test
public void testCriteria() {
    SessionFactory sessionFactory = HibernateUtils.getSessionFactory();

    Session session = sessionFactory.openSession();

    CriteriaBuilder criteriaBuilder = session.getCriteriaBuilder();

    // 查询所有
    // CriteriaQuery<User> criteriaQuery = criteriaBuilder.createQuery(User.class);
    // // 跟条件
    // Root<User> root = criteriaQuery.from(User.class);
    // Query<User> query = session.createQuery(criteriaQuery);
    // List<User> userList = query.list();
    // for (User user : userList) {
    //     System.out.println(user);
    // }

    // 查询单一属性
    // CriteriaQuery<String> criteriaQuery = criteriaBuilder.createQuery(String.class);
    // Root<User> root = criteriaQuery.from(User.class);
    // // 查询的字段
    // criteriaQuery.select(root.get("username"));
    // Query<String> query = session.createQuery(criteriaQuery);
    // List<String> list = query.list();
    // for (String s : list) {
    //     System.out.println("用户名：" + s);
    // }

    // 条件查询
    CriteriaQuery<User> criteriaQuery = criteriaBuilder.createQuery(User.class);
    Root<User> root = criteriaQuery.from(User.class);
    criteriaQuery.select(root);  // 查询所有字段可省略
    criteriaQuery.where(criteriaBuilder.equal(root.get("username"), "小昭"));
    Query<User> query = session.createQuery(criteriaQuery);
    List<User> userList = query.list();
    for (User user : userList) {
        System.out.println(user);
    }
}
```

##### 3、SQLQuery

###### 3.1、查询所有

```java
/**
 * API：SQLQuery
 */
@Test
public void testSQLQuery() {
    SessionFactory sessionFactory = HibernateUtils.getSessionFactory();

    Session session = sessionFactory.openSession();

    // 查询所有
    String sql = "select * from tb_user";
    NativeQuery sqlQuery = session.createSQLQuery(sql);
    sqlQuery.addEntity(User.class);
    List<User> userList = sqlQuery.list();
    for (User user : userList) {
        System.out.println(user);
    }
}
```

###### 3.2、条件查询

```java
/**
 * API：SQLQuery
 */
@Test
public void testSQLQuery() {
    SessionFactory sessionFactory = HibernateUtils.getSessionFactory();

    Session session = sessionFactory.openSession();

    // 查询所有
    // String sql = "select * from tb_user";
    // NativeQuery sqlQuery = session.createSQLQuery(sql);
    // sqlQuery.addEntity(User.class);
    // List<User> userList = sqlQuery.list();
    // for (User user : userList) {
    //     System.out.println(user);
    // }

    // 条件查询
    String sql = "select * from tb_user where name = ? or addr = ?";
    NativeQuery sqlQuery = session.createSQLQuery(sql);
    sqlQuery.addEntity(User.class);
    sqlQuery.setParameter(1, "小昭");
    sqlQuery.setParameter(2, "武当山");
    List<User> userList = sqlQuery.list();
    for (User user : userList) {
        System.out.println(user);
    }

}
```

**课后作业**

1. 事务的四大特性是什么？简要说明一下四大特性
2. 在不考虑隔离级别的情况下，会产生什么样的问题，简要说明产生的问题
3. 事务的规范性代码如何编写，请写一个事务规范代码的模板
4. 请分别写一条查询所有的HQL语句和SQL语句

#### 十三、表与表之间的关系

​	一对一、一对多、多对多

##### 1、一对多

![image-20220314090522585](/TyporaPic/image-20220314090522585.png)

###### 1.1、创建客户实体类

```java
package com.hbnu.pojo;

/**
 * @author chendikai
 */
public class Customer {
    
    private int cid;
    private String name;
    private String address;

    public int getCid() {
        return cid;
    }

    public void setCid(int cid) {
        this.cid = cid;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }
}
```

###### 1.2、创建联系人实体类

```java
package com.hbnu.pojo;

/**
 * @author chendikai
 */
public class LinkMan {
    
    private int uid;
    private String username;
    private String tel;
    private String gender;

    public int getUid() {
        return uid;
    }

    public void setUid(int uid) {
        this.uid = uid;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getTel() {
        return tel;
    }

    public void setTel(String tel) {
        this.tel = tel;
    }

    public String getGender() {
        return gender;
    }

    public void setGender(String gender) {
        this.gender = gender;
    }
}
```

###### 1.3、实体类联系

​	表与表之间存在一对多的关系，那么实体类也应该存在一对多的关系，因此需要修改上述两个实体类

- 修改客户实体类

```java
package com.hbnu.pojo;

import java.util.HashSet;
import java.util.Set;

/**
 * @author chendikai
 */
public class Customer {

    private int cid;
    private String name;
    private String address;
    
    Set<LinkMan> linkManSet =  new HashSet<>();

    public Set<LinkMan> getLinkManSet() {
        return linkManSet;
    }

    public void setLinkManSet(Set<LinkMan> linkManSet) {
        this.linkManSet = linkManSet;
    }

    public int getCid() {
        return cid;
    }

    public void setCid(int cid) {
        this.cid = cid;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }
}
```

- 修改联系人实体类

```java
package com.hbnu.pojo;

/**
 * @author chendikai
 */
public class LinkMan {

    private int uid;
    private String username;
    private String tel;
    private String gender;
    
    private Customer customer;

    public Customer getCustomer() {
        return customer;
    }

    public void setCustomer(Customer customer) {
        this.customer = customer;
    }

    public int getUid() {
        return uid;
    }

    public void setUid(int uid) {
        this.uid = uid;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getTel() {
        return tel;
    }

    public void setTel(String tel) {
        this.tel = tel;
    }

    public String getGender() {
        return gender;
    }

    public void setGender(String gender) {
        this.gender = gender;
    }
}
```

###### 1.4、创建客户配置文件

```xml
<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
        "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
<hibernate-mapping>
    <class name="com.hbnu.pojo.Customer" table="tb_customer">
        <id name="cid" column="cid">
            <!-- 主键生成策略 -->
            <generator class="native"></generator>
        </id>

        <property name="name" column="name"/>
        <property name="address" column="addr"/>

        <!-- 配置客户和联系人之间的关系 -->
        <set name="linkManSet">
            <!-- 客户在联系人表中的外键名称, Hibernate框架外键需要双向维护 -->
            <key column="ucid"></key>
            
            <one-to-many class="com.hbnu.pojo.LinkMan"></one-to-many>
        </set>
    </class>
</hibernate-mapping>
```

###### 1.5、创建联系人配置文件

```xml
<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
        "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
<hibernate-mapping>
    <class name="com.hbnu.pojo.LinkMan" table="tb_linkman">
        <id name="uid" column="id">
            <generator class="native"></generator>
        </id>

        <property name="username" column="name"/>
        <property name="tel"/>
        <property name="gender"/>

        <many-to-one name="customer" class="com.hbnu.pojo.Customer" column="ucid"/>
    </class>
</hibernate-mapping>
```

###### 1.6、修改核心配置文件

```xml
<?xml version="1.0" encoding="utf-8" ?>
<!-- 引入核心配置文件头信息 -->
<!DOCTYPE hibernate-configuration PUBLIC
        "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
        "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd">
<hibernate-configuration>
    <!-- 配置hibernate核心配置文件 -->
    <session-factory>
        <!-- 1、数据库信息 必需 -->
        <property name="hibernate.connection.driver_class">com.mysql.cj.jdbc.Driver</property>
        <property name="hibernate.connection.url">jdbc:mysql://localhost:3306/classDB?serverTimezone=GMT&amp;useSSL=false&amp;characterEncoding=utf-8</property>
        <property name="hibernate.connection.username">root</property>
        <property name="hibernate.connection.password">chendikai</property>

        <!-- 2、hibernate信息 非必需 -->
        <!-- 在控制台输出hibernate底层生成的SQL语句 -->
        <property name="show_sql">true</property>
        <!-- 格式化hibernate底层生成的SQL语句 -->
        <property name="format_sql">true</property>
        <!-- 数据库方言 -->
        <property name="hibernate.dialect">org.hibernate.dialect.MySQL5Dialect</property>
        <!-- hibernate自动创建数据库表，如果表已经存在，则更新表，如果不存在，则创建表格 -->
        <property name="hibernate.hbm2ddl.auto">update</property>
        <!-- 设置事务的隔离级别 -->
        <property name="hibernate.connection.isolation">4</property>
        <!-- session绑定本地线程 -->
        <property name="current_session_context_class">thread</property>

        <!-- 3、引用hibernate映射关系配置文件 必需 -->
        <mapping resource="com/hbnu/config/user.hbm.xml"></mapping>

        <!-- 引入一对多映射关系配置文件 -->
        <mapping resource="com/hbnu/config/customer.hbm.xml"/>
        <mapping resource="com/hbnu/config/linkman.hbm.xml"/>
    </session-factory>
</hibernate-configuration>
```

###### 1.7、创建表

​	可以直接运行Hibernate工具类

```java
package com.hbnu.util;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.cfg.Configuration;

/**
 * @author chendikai
 */
public class HibernateUtils {

    private static Configuration configuration;
    private static SessionFactory sessionFactory;

    static {
        configuration = new Configuration().configure();
        sessionFactory = configuration.buildSessionFactory();
    }

    public static SessionFactory getSessionFactory() {
        return sessionFactory;
    }

    public static Session getSession() {
        return sessionFactory.getCurrentSession();  // 返回绑定本地线程的session对象
    }

    public static void main(String[] args) {

    }
}
```

##### 2、级联操作

- 级联保存：当我们保存一的一方（客户）的时候，可以自动保存多的一方（联系人）
- 级联删除：当我们删除一的一方（客户）的时候，可以自动删除多的一方（联系人）

###### 2.1、保存数据

- 未采用级联保存

```java
/**
 * 一对多保存操作
 */
@Test
public void testSave() {
    SessionFactory sessionFactory = HibernateUtils.getSessionFactory();

    Session session = sessionFactory.openSession();

    Transaction transaction = session.beginTransaction();

    Customer customer = new Customer();
    customer.setName("百度");
    customer.setAddress("深圳");

    Customer customer1 = new Customer();
    customer1.setName("腾讯");
    customer1.setAddress("广州");

    LinkMan linkMan = new LinkMan();
    linkMan.setUsername("李彦宏");
    linkMan.setTel("110");
    linkMan.setGender("男");

    LinkMan linkMan1 = new LinkMan();
    linkMan1.setUsername("陈迪凯");
    linkMan1.setTel("119");
    linkMan1.setGender("男");

    LinkMan linkMan2 = new LinkMan();
    linkMan2.setUsername("马化腾");
    linkMan2.setTel("120");
    linkMan2.setGender("女");

    LinkMan linkMan3 = new LinkMan();
    linkMan3.setUsername("张小龙");
    linkMan3.setTel("114");
    linkMan3.setGender("男");

    customer.getLinkManSet().add(linkMan);
    customer.getLinkManSet().add(linkMan1);
    linkMan.setCustomer(customer);
    linkMan1.setCustomer(customer);

    customer1.getLinkManSet().add(linkMan2);
    customer1.getLinkManSet().add(linkMan3);
    linkMan2.setCustomer(customer1);
    linkMan3.setCustomer(customer1);
    
    // 保存数据
    session.save(customer);
    session.save(customer1);
    
    session.save(linkMan);
    session.save(linkMan1);
    session.save(linkMan2);
    session.save(linkMan3);
    
    transaction.commit();
    
    session.close();
    sessionFactory.close();

}
```

- 采用级联保存

1. 修改映射关系配置文件

    级联保存需要修改一的一方（客户）的映射关系配置文件

    ```xml
    <!-- 配置客户和联系人之间的关系
     cascad..值为save-update表示级联保存
     -->
    <set name="linkManSet" cascade="save-update">
        <!-- 客户在联系人表中的外键名称, Hibernate框架外键需要双向维护 -->
        <key column="ucid"></key>
    
        <!-- clas属性：一对多中，多的一方的类的全路径-->
        <one-to-many class="com.hbnu.pojo.LinkMan"></one-to-many>
    </set>
    ```

级联保存

```java
/**
 * 一对多保存操作
 */
@Test
public void testSave() {
    SessionFactory sessionFactory = HibernateUtils.getSessionFactory();

    Session session = sessionFactory.openSession();

    Transaction transaction = session.beginTransaction();

    // Customer customer = new Customer();
    // customer.setName("百度");
    // customer.setAddress("深圳");
    //
    // Customer customer1 = new Customer();
    // customer1.setName("腾讯");
    // customer1.setAddress("广州");
    //
    // LinkMan linkMan = new LinkMan();
    // linkMan.setUsername("李彦宏");
    // linkMan.setTel("110");
    // linkMan.setGender("男");
    //
    // LinkMan linkMan1 = new LinkMan();
    // linkMan1.setUsername("陈迪凯");
    // linkMan1.setTel("119");
    // linkMan1.setGender("男");
    //
    // LinkMan linkMan2 = new LinkMan();
    // linkMan2.setUsername("马化腾");
    // linkMan2.setTel("120");
    // linkMan2.setGender("女");
    //
    // LinkMan linkMan3 = new LinkMan();
    // linkMan3.setUsername("张小龙");
    // linkMan3.setTel("114");
    // linkMan3.setGender("男");
    //
    // customer.getLinkManSet().add(linkMan);
    // customer.getLinkManSet().add(linkMan1);
    // linkMan.setCustomer(customer);
    // linkMan1.setCustomer(customer);
    //
    // customer1.getLinkManSet().add(linkMan2);
    // customer1.getLinkManSet().add(linkMan3);
    // linkMan2.setCustomer(customer1);
    // linkMan3.setCustomer(customer1);
    //
    // // 保存数据
    // session.save(customer);
    // session.save(customer1);
    //
    // session.save(linkMan);
    // session.save(linkMan1);
    // session.save(linkMan2);
    // session.save(linkMan3);

    Customer customer = new Customer();
    customer.setName("小米");
    customer.setAddress("武汉");

    LinkMan linkMan = new LinkMan();
    linkMan.setUsername("雷军");
    linkMan.setTel("119");
    linkMan.setGender("男");

    LinkMan linkMan2 = new LinkMan();
    linkMan2.setUsername("张勇");
    linkMan2.setTel("114");
    linkMan2.setGender("男");

    customer.getLinkManSet().add(linkMan);
    customer.getLinkManSet().add(linkMan2);
    linkMan.setCustomer(customer);
    linkMan2.setCustomer(customer);

    // 在一对多中，级联保存只需要保存一的一方，自动保存多的一方
    session.save(customer);

    transaction.commit();

    session.close();
    sessionFactory.close();

}
```

###### 2.2、级联删除（需要了解删除过程）

​	修改hibernate底层生成数据库表的引擎，需要修改hibernate核心配置文件的方言

```xml
<!-- 数据库方言 -->
<property name="hibernate.dialect">org.hibernate.dialect.MySQL55Dialect</property>
```

1. 修改一对多中一的一方（客户）中映射关系配置文件

    ```xml
    <!-- 配置客户和联系人之间的关系
     cascad..值为save-update表示级联保存
     cascad..值为delete表示级联删除
     -->
    <set name="linkManSet" cascade="save-update, delete">
        <!-- 客户在联系人表中的外键名称, Hibernate框架外键需要双向维护 -->
        <key column="ucid"></key>
    
        <!-- clas属性：一对多中，多的一方的类的全路径-->
        <one-to-many class="com.hbnu.pojo.LinkMan"></one-to-many>
    </set>
    ```

2. 级联删除

    ```java
    /**
     * 一对多级联删除
     */
    @Test
    public void testOneToManyDelete() {
    
        SessionFactory sessionFactory = HibernateUtils.getSessionFactory();
    
        Session session = sessionFactory.openSession();
    
        Transaction transaction = session.beginTransaction();
    
        Customer customer = session.get(Customer.class, 3);
        session.delete(customer);
    
        transaction.commit();
    
        session.close();
        sessionFactory.close();
    }
    ```

###### 3、修改

```java
/**
 * 一对多修改
 */
@Test
public void testOneToManyUpdate() {
    SessionFactory sessionFactory = HibernateUtils.getSessionFactory();

    Session session = sessionFactory.openSession();

    Transaction transaction = session.beginTransaction();

    Customer customer = session.get(Customer.class, 1);
    LinkMan linkMan = session.get(LinkMan.class, 4);

    customer.getLinkManSet().add(linkMan);
    linkMan.setCustomer(customer);

    transaction.commit();

    session.close();
    sessionFactory.close();
}
```

​	上述修改过程功能没有问题，但是存在性能问题，因为Hibernate双向维护外键机制，导致修改的时候，对外键的修改执行了两次，因此可以让一方放弃外键的维护，在一对多中，可以让一的一方放弃外键的维护，此时需要修改一的一方的映射关系配置文件，修改如下：

```xml
<!-- 配置客户和联系人之间的关系
 cascad..值为save-update表示级联保存
 cascad..值为delete表示级联删除
 invers..值为true表示放弃外键的维护
 -->
<set name="linkManSet" cascade="save-update, delete" inverse="true">
    <!-- 客户在联系人表中的外键名称, Hibernate框架外键需要双向维护 -->
    <key column="ucid"></key>

    <!-- clas属性：一对多中，多的一方的类的全路径 -->
    <one-to-many class="com.hbnu.pojo.LinkMan"></one-to-many>
</set>
```

##### 3、多对多

​	多对多建表需要借助第三方中间表，第三方中间表至少有两个字段，分别指向两个表的主键

![image-20220321080956551](/TyporaPic/image-20220321080956551.png)

###### 3.1、创建玩家和角色实体类

- 玩家实体类

    ```java
    package com.hbnu.pojo;
    
    /**
     * @author chendikai
     */
    public class Player {
        
        private int pid;
        private String name;
        private String gender;
    
        public int getPid() {
            return pid;
        }
    
        public void setPid(int pid) {
            this.pid = pid;
        }
    
        public String getName() {
            return name;
        }
    
        public void setName(String name) {
            this.name = name;
        }
    
        public String getGender() {
            return gender;
        }
    
        public void setGender(String gender) {
            this.gender = gender;
        }
    
        @Override
        public String toString() {
            return "Player{" +
                    "pid=" + pid +
                    ", name='" + name + '\'' +
                    ", gender='" + gender + '\'' +
                    '}';
        }
    }
    ```
    
- 角色实体类

    ```java
    package com.hbnu.pojo;
    
    /**
     * @author chendikai
     */
    public class Role {
        private int rid;
        private String name;
        private String description;
    
        public int getRid() {
            return rid;
        }
    
        public void setRid(int rid) {
            this.rid = rid;
        }
    
        public String getName() {
            return name;
        }
    
        public void setName(String name) {
            this.name = name;
        }
    
        public String getDescription() {
            return description;
        }
    
        public void setDescription(String description) {
            this.description = description;
        }
    
        @Override
        public String toString() {
            return "Role{" +
                    "rid=" + rid +
                    ", name='" + name + '\'' +
                    ", description='" + description + '\'' +
                    '}';
        }
    }
    ```

###### 3.2、实体类互相表示（多对多关系）

- 修改玩家实体类

    ```java
    package com.hbnu.pojo;
    
    import java.util.HashSet;
    import java.util.Set;
    
    /**
     * @author chendikai
     */
    public class Player {
    
        private int pid;
        private String name;
        private String gender;
        
        Set<Role> roles = new HashSet<>();
    
        public Set<Role> getRoles() {
            return roles;
        }
    
        public void setRoles(Set<Role> roles) {
            this.roles = roles;
        }
    
        public int getPid() {
            return pid;
        }
    
        public void setPid(int pid) {
            this.pid = pid;
        }
    
        public String getName() {
            return name;
        }
    
        public void setName(String name) {
            this.name = name;
        }
    
        public String getGender() {
            return gender;
        }
    
        public void setGender(String gender) {
            this.gender = gender;
        }
    
        @Override
        public String toString() {
            return "Player{" +
                    "pid=" + pid +
                    ", name='" + name + '\'' +
                    ", gender='" + gender + '\'' +
                    '}';
        }
    }
    ```
    
- 修改角色表

    ```java
    package com.hbnu.pojo;
    
    import java.util.HashSet;
    import java.util.Set;
    
    /**
     * @author chendikai
     */
    public class Role {
        private int rid;
        private String name;
        private String description;
        
        Set<Player> players = new HashSet<>();
    
        public Set<Player> getPlayers() {
            return players;
        }
    
        public void setPlayers(Set<Player> players) {
            this.players = players;
        }
    
        public int getRid() {
            return rid;
        }
    
        public void setRid(int rid) {
            this.rid = rid;
        }
    
        public String getName() {
            return name;
        }
    
        public void setName(String name) {
            this.name = name;
        }
    
        public String getDescription() {
            return description;
        }
    
        public void setDescription(String description) {
            this.description = description;
        }
    
        @Override
        public String toString() {
            return "Role{" +
                    "rid=" + rid +
                    ", name='" + name + '\'' +
                    ", description='" + description + '\'' +
                    '}';
        }
    }
    ```

###### 3.3、创建配置文件

​	创建玩家和角色映射关系配置文件，并在配置文件中互相表示多对多的关系

- 玩家配置文件

    ```xml
    <?xml version="1.0" encoding="utf-8" ?>
    <!DOCTYPE hibernate-mapping PUBLIC
            "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
            "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
    <hibernate-mapping>
    
        <class name="com.hbnu.pojo.Player" table="tb_player">
            <id name="pid">
                <generator class="native"></generator>
            </id>
    
            <property name="name"/>
            <property name="gender"/>
    
            <!-- 配置多对多的关系 -->
            <set name="roles" table="tb_playrole">
                <!--
                key:表示当前配置文件所属实体类在第三方中间表的外键
                -->
                <key column="pid"></key>
                <!--
                class:多对多中另外一张表对应的实体类全路径
                column:另一张表在第三张中间表的外键字段名
                -->
                <many-to-many class="com.hbnu.pojo.Role" column="rid"></many-to-many>
            </set>
        </class>
    </hibernate-mapping>
    ```

- 角色配置文件

    ```xml
    <?xml version="1.0" encoding="utf-8" ?>
    <!DOCTYPE hibernate-mapping PUBLIC
            "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
            "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
    <hibernate-mapping>
    
        <class name="com.hbnu.pojo.Role" table="tb_role">
            <id name="rid">
                <generator class="native"></generator>
            </id>
    
            <property name="name"/>
            <!-- column属性值和数据库SQL中的关键字不能重名 -->
            <property name="description" column="des"/>
    
            <set name="players" table="tb_playrole">
                <key column="rid"></key>
                <many-to-many class="com.hbnu.pojo.Player" column="pid"></many-to-many>
            </set>
        </class>
    </hibernate-mapping>
    ```

- 核心配置文件引用映射关系配置文件

    ```xml
    <?xml version="1.0" encoding="utf-8" ?>
    <!-- 引入核心配置文件头信息 -->
    <!DOCTYPE hibernate-configuration PUBLIC
            "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
            "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd">
    <hibernate-configuration>
        <!-- 配置hibernate核心配置文件 -->
        <session-factory>
            <!-- 1、数据库信息 必需 -->
            <property name="hibernate.connection.driver_class">com.mysql.cj.jdbc.Driver</property>
            <property name="hibernate.connection.url">jdbc:mysql://localhost:3306/classDB?serverTimezone=GMT&amp;useSSL=false&amp;characterEncoding=utf-8</property>
            <property name="hibernate.connection.username">root</property>
            <property name="hibernate.connection.password">chendikai</property>
    
            <!-- 2、hibernate信息 非必需 -->
            <!-- 在控制台输出hibernate底层生成的SQL语句 -->
            <property name="show_sql">true</property>
            <!-- 格式化hibernate底层生成的SQL语句 -->
            <property name="format_sql">true</property>
            <!-- 数据库方言 -->
            <property name="hibernate.dialect">org.hibernate.dialect.MySQL55Dialect</property>
            <!-- hibernate自动创建数据库表，如果表已经存在，则更新表，如果不存在，则创建表格 -->
            <property name="hibernate.hbm2ddl.auto">update</property>
            <!-- 设置事务的隔离级别 -->
            <property name="hibernate.connection.isolation">4</property>
            <!-- session绑定本地线程 -->
            <property name="current_session_context_class">thread</property>
    
            <!-- 3、引用hibernate映射关系配置文件 必需 -->
            <mapping resource="com/hbnu/config/user.hbm.xml"></mapping>
    
            <!-- 引入一对多映射关系配置文件 -->
            <mapping resource="com/hbnu/config/customer.hbm.xml"/>
            <mapping resource="com/hbnu/config/linkman.hbm.xml"/>
            
            <!-- 引入多对多映射关系配置文件 -->
            <mapping resource="com/hbnu/config/player.hbm.xml"/>
            <mapping resource="com/hbnu/config/role.hbm.xml"/>
        </session-factory>
    </hibernate-configuration>
    ```

##### 4、级联操作

###### 4.1、级联保存

- 添加级联配置

    ```xml
    <!-- 配置多对多的关系 -->
    <set name="roles" table="tb_playrole" cascade="save-update">
        <!--
        key:表示当前配置文件所属实体类在第三方中间表的外键
        -->
        <key column="pid"></key>
        <!--
        class:多对多中另外一张表对应的实体类全路径
        column:另一张表在第三种中间表的外键字段名
        -->
        <many-to-many class="com.hbnu.pojo.Role" column="rid"></many-to-many>
    </set>
    ```

- 测试

    ```java
    /**
     * 多对多级联保存
     */
    @Test
    public void testManyToManySave() {
        SessionFactory sessionFactory = HibernateUtils.getSessionFactory();
    
        Session session = sessionFactory.openSession();
    
        Transaction transaction = session.beginTransaction();
    
        // 需求：玩家一有射手和辅助的角色，玩家二有法师和辅助的角色
        Player player1 = new Player();
        player1.setName("陈迪凯");
        player1.setGender("男");
    
        Player player2 = new Player();
        player2.setName("小昭");
        player2.setGender("女");
    
        Role role1 = new Role();
        role1.setName("法师");
        role1.setDescription("远程AP输出");
    
        Role role2 = new Role();
        role2.setName("射手");
        role2.setDescription("远程AD输出");
    
        Role role3 = new Role();
        role3.setName("辅助");
        role3.setDescription("保护我方输出");
    
        player1.getRoles().add(role2);
        player1.getRoles().add(role3);
    
        player2.getRoles().add(role1);
        player2.getRoles().add(role3);
    
        session.save(player1);
        session.save(player2);
    
        transaction.commit();
    
        session.close();
        sessionFactory.close();
    }
    ```

###### 4.2、级联删除

- 添加级联配置

    ```xml
    <!-- 配置多对多的关系 -->
    <set name="roles" table="tb_playrole" cascade="save-update, delete">
        <!--
        key:表示当前配置文件所属实体类在第三方中间表的外键
        -->
        <key column="pid"></key>
        <!--
        class:多对多中另外一张表对应的实体类全路径
        column:另一张表在第三种中间表的外键字段名
        -->
        <many-to-many class="com.hbnu.pojo.Role" column="rid"></many-to-many>
    </set>
    ```

- 测试

    ```java
    /**
     * 多对多级联删除
     */
    @Test
    public void testManyToManyDelete() {
        SessionFactory sessionFactory = HibernateUtils.getSessionFactory();
    
        Session session = sessionFactory.openSession();
    
        Transaction transaction = session.beginTransaction();
    
        Player player = session.get(Player.class, 2);
        session.delete(player);
    
        transaction.commit();
    
        session.close();
        sessionFactory.close();
    }
    ```

    说明：多对多中级联删除会出现误删的情况。因此在实际开发中多对多关系不能使用级联删除。

- 不使用级联删除

    ```xml
    <!-- 配置多对多的关系 -->
    <set name="roles" table="tb_playrole" cascade="save-update">
        <!--
        key:表示当前配置文件所属实体类在第三方中间表的外键
        -->
        <key column="pid"></key>
        <!--
        class:多对多中另外一张表对应的实体类全路径
        column:另一张表在第三种中间表的外键字段名
        -->
        <many-to-many class="com.hbnu.pojo.Role" column="rid"></many-to-many>
    </set>
    ```

- 测试

    ```java
    /**
     * 多对多删除
     */
    @Test
    public void testManyToManyDelete() {
        SessionFactory sessionFactory = HibernateUtils.getSessionFactory();
    
        Session session = sessionFactory.openSession();
    
        Transaction transaction = session.beginTransaction();
    
        Player player = session.get(Player.class, 2);
        session.delete(player);
    
        transaction.commit();
    
        session.close();
        sessionFactory.close();
    }
    ```

###### 4.3、修改

​	多对多中关系的维护主要通过第三张中间表来维护

- 让玩家拥有一个角色

```java
/**
 * 多对多修改操作
 */
@Test
public void testManyToManyUpdate() {
    SessionFactory sessionFactory = HibernateUtils.getSessionFactory();

    Session session = sessionFactory.openSession();

    Transaction transaction = session.beginTransaction();

    Player player = session.get(Player.class, 1);
    Role role = session.get(Role.class, 6);
    player.getRoles().add(role);
    
    transaction.commit();
    
    session.close();
    sessionFactory.close();
}
```

- 让玩家没有某个角色

```java
/**
 * 多对多修改操作
 */
@Test
public void testManyToManyUpdate() {
    SessionFactory sessionFactory = HibernateUtils.getSessionFactory();

    Session session = sessionFactory.openSession();

    Transaction transaction = session.beginTransaction();

    Player player = session.get(Player.class, 1);
    Role role = session.get(Role.class, 6);
    // player.getRoles().add(role);
    player.getRoles().remove(role);

    transaction.commit();

    session.close();
    sessionFactory.close();
}
```

#### 十四、Hibernate查询方式

- 对象导航查询

​	  使用场景：在一对多中，根据id查询客户信息，再查询客户对应的所有联系人

- OID查询

​	  使用场景：根据id查询某一条记录，返回的是对象

- hql查询

​	  Query对象，写hql语句实现查询

- QBC查询

​	  Criteria对象

- 本地SQL查询

​	  SQLQuery对象，使用普通sql查询

##### 1、对象导航查询

```java
@Test
public void testSelect1() {
    SessionFactory sessionFactory = null;
    Session session = null;
    Transaction transaction = null;
    try {
        // 通过工具类生成sessionFactory对象
        sessionFactory = HibernateUtil.getSessionFactory();

        // 3、获取session对象
        session = sessionFactory.openSession();

        // 4、手动开启事务
        transaction = session.beginTransaction();

        // 5、需求：查询cid=1的客户，再查询这个客户的所有联系人
        Customer customer = session.get(Customer.class, 1);
        // 再查询这个客户的所有联系人，直接得到客户对象里面的set集合
        Set<LinkMan> linkManSet = customer.getLinkManSet();
        System.out.println(linkManSet.size());

        // 6、提交事务
        transaction.commit();
    } catch (HibernateException e) {
        e.printStackTrace();
        // 回滚事务
        transaction.rollback();
    } finally {
        // 7、关闭资源
        session.close();
        sessionFactory.close();
    }
}
```

##### 2、OID查询

```java
@Test
public void testSelect2() {
    SessionFactory sessionFactory = null;
    Session session = null;
    Transaction transaction = null;
    try {
        // 通过工具类生成sessionFactory对象
        sessionFactory = HibernateUtil.getSessionFactory();

        // 3、获取session对象
        session = sessionFactory.openSession();

        // 4、手动开启事务
        transaction = session.beginTransaction();

        // 5、需求：查询cid=1的客户(OID查询)
        Customer customer = session.get(Customer.class, 1);

        // 6、提交事务
        transaction.commit();
    } catch (HibernateException e) {
        e.printStackTrace();
        // 回滚事务
        transaction.rollback();
    } finally {
        // 7、关闭资源
        session.close();
        sessionFactory.close();
    }
}
```

##### 3、hql查询

- 查询所有(主要代码)

    ```java
    Query query = session.createQuery("from Customer");
    List<Customer> list = query.list();
    ```

- 条件查询

    语法一：from 实体类名称 where 实体类属性名称=?索引下标 and 实体类属性名称=?索引下标;

    语法二：from 实体类名称 where 实体类属性名称=:参数名 and 实体类属性名称=:参数名;

    ```java
    Query query = session.createQuery("from Customer where cid = ?0 and custName = ?1");
    // 给?设置值，此处?的位置从0开始
    query.setParameter(0, 1);
    query.setParameter(1, "湖师");
    // 调用方法获取结果
    List<Customer> list = query.list();
    ```

- 排序查询

    语法：from 实体类名称 order by 实体类属性名称 ASC/DESC;

    ```java
    Query query = session.createQuery("from Customer ORDER BY cid desc");
    List<Customer> list = query.list();
    ```

- 分页查询

    在hql中，hql语句里面不能写limit，Hibernate中的Query对象封装了两个方法实现分页操作

    ```java
    Query query = session.createQuery("from Customer");
    
    // 设置分页数据
    // 设置开始位置
    query.setFirstResult(0);
    // 设置每页的记录数
    query.setMaxResults(3);
    
    // 调用方法获取结果
    List<Customer> list = query.list();
    ```

- 投影查询

    查询的是部分字段的值，而不是所有字段

    语法：select 实体类名称1,实体类名称2 from 实体类名称;

    注意：select后面不能用*

    ```java
    Query query = session.createQuery("select custName from Customer");
    
    // 调用方法获取结果
    List<Object> list = query.list();
    ```

- 聚集函数使用

    常用聚集函数：count、sum、avg、max、min

    语法：select count(*) from 实体类名称

    ```java
    Query query = session.createQuery("select count(*) from Customer");
    
    // 调用方法得到结果，query对象里面有方法直接返回对象形式
    Object object = query.uniqueResult();
    ```

##### 4、QBC查询

​	  使用QBC查询时不需要写语句，使用方法实现查询；操作的是实体类和属性；通过Criteria对象实现

- 查询所有

    ```java
    // 创建criteria对象
    Criteria criteria = session.createCriteria(Customer.class);
    
    // 调用方法得到结果
    List<Customer> list = criteria.list();
    ```

- 条件查询

    ```java
    // 创建criteria对象
    Criteria criteria = session.createCriteria(Customer.class);
    
    // 使用Criteria对象里面的方法设置条件值
    criteria.add(Restrictions.eq("cid", 1));
    criteria.add(Restrictions.eq("custName", "湖师"));
    
    // 调用方法得到结果
    List<Customer> list = criteria.list();
    ```

- 排序查询

    ```java
    // 创建criteria对象
    Criteria criteria = session.createCriteria(Customer.class);
    
    // 设置对哪个属性进行排序，设置排序规则
    criteria.addOrder(Order.asc("cid"));
    
    // 调用方法得到结果
    List<Customer> list = criteria.list();
    ```

- 分页查询

    ```java
    // 创建criteria对象
    Criteria criteria = session.createCriteria(Customer.class);
    
    // 设置分页数据
    // 设置开始位置
    criteria.setFirstResult(0);
    // 设置每页的记录数
    criteria.setMaxResults(3);
    
    // 调用方法得到结果
    List<Customer> list = criteria.list();
    ```

- 统计查询

    ```java
    // 创建criteria对象
    Criteria criteria = session.createCriteria(Customer.class);
    
    // 设置操作
    criteria.setProjection(Projections.rowCount());
    
    // 调用方法得到结果
    Object obj = criteria.uniqueResult();
    Long longObj = (Long)obj;
    int count = longObj.intValue();
    ```

- 离线查询

    不需要通过session创建criteria对象

    ```java
    // 创建对象
    DetachedCriteria detachedCriteria = DetachedCriteria.forClass(Customer.class);
    
    // 最终执行时才会用到session
    Criteria criteria = detachedCriteria.getExecutableCriteria(session);
    
    // 调用方法得到结果
    List<Customer> list = criteria.list();
    ```

##### 5、HQL多表查询

###### 5.1、MySQL表中的多表查询

- 内连接

- 左外连接
- 右外连接

###### 5.2、HQL实现多表查询

- 内连接

    语句：from Customer c inner join c.linkManSet

    ```java
    // 获取query对象
    Query query = session.createQuery("from Customer c inner join c.linkManSet")
        
    // 调用方法得到结果
    List list = query.list();
    ```

    list中每部分是数组

- 左外连接

    语句：from Customer c left outer join c.linkManSet

    ```java
    // 获取query对象
    Query query = session.createQuery("from Customer c left outer join c.linkManSet")
        
    // 调用方法得到结果
    List list = query.list();
    ```

    list中每部分是数组

- 右外连接

    语句：from Customer c right outer join c.linkManSet

    ```java
    // 获取query对象
    Query query = session.createQuery("from Customer c right outer join c.linkManSet")
        
    // 调用方法得到结果
    List list = query.list();
    ```

    list中每部分是数组

- 迫切内连接

    迫切内连接和内连接底层实现是一样的，区别：内连接返回的list中每部分是数组，迫切内连接list中返回的是对象

    语句：from Customer c inner join fetch c.linkManSet

    ```java
    // 获取query对象
    Query query = session.createQuery("from Customer c inner join fetch c.linkManSet")
        
    // 调用方法得到结果
    List list = query.list();
    ```

- 迫切左外连接

    语句：from Customer c left outer join fetch c.linkManSet

    ```java
    // 获取query对象
    Query query = session.createQuery("from Customer c left outer join fetch c.linkManSet")
        
    // 调用方法得到结果
    List list = query.list();
    ```

#### 十五、Hibernate检索策略

##### 1、检索策略概念

​	hibernate检索策略分为两种：

- 立即查询

    根据id查询，调用get方法，一调用get方法马上发送语句查询数据库

    ```java
    // 查询cid为1的消费者信息
    Customer customer = session.get(Customer.class, 1);
    ```

- 延迟查询

    根据id查询，还有load方法，调用load方法不会马上查询数据库，只有得到对象里面的值时才会发送语句查询数据库

    ```java
    // 查询cid为1的消费者信息，调用load方法不会立即发送sql语句查询数据库，返回的对象里面只有id值，只有得到对象里面除id值之外的其他值时才会发送语句查询数据库
    Customer customer = session.load(Customer.class, 1);
    ```

    延迟查询又分为两类

    - 类级别延迟
    
    - 关联级别延迟
    
        查询某个客户，再查询这个客户的所有联系人，查询这个客户的所有联系人的过程是否需要延迟，这个过程称为关联级别延迟


```java
// 查询cid为1的用户的所有联系人
Customer customer = session.get(Customer.class, 1); // 此条语句会立即发送语句查询数据库

// 查询这个客户的所有联系人
Set<LinkMan> linkManSet = customer.getLinkManSet(); // 此条语句没有发送sql语句

// 获取联系人中的属性
System.out.println(linkManSet.size()); // 此条语句会发送语句
```


**关联级别延迟修改**

- 在映射文件中进行配置

    根据客户得到联系人，在客户映射配置文件进行配置

- 在set标签使用属性

    fetch属性：值select（默认值）

    lazy属性：值true(延迟)（默认值）、值false(不延迟)、exra(及其延迟)

- 批量抓取

    场景：先查询所有客户，再查询每个客户的所有联系人

    ```java
    // 查询所有客户
    Critreia criteria = session.createCriteria(Customer.class);
    List<Customer> list = criteria.list();
    
    // 再查询每个客户的所有联系人
    for (Customer customer : list) {
        // 每个客户的所有联系人
        Set<LinkMan> linkManSet = customer.getLinkManSet();
    }
    ```

    上述操作代码会发送多条sql语句查询数据库，可以使用批量抓取进行优化

    配置：在用户映射配置文件的set标签中配置batch-size的值，这个值为整数，值越大，效率越高

    ```xml
    <set name="linkManSet" batch-size="10">
    ......
    </set>
    ```
